===========================
パート13: Deferred と行こう
===========================

はじめに
--------

.. _figure28:

.. figure:: images/p13_deferred-12.png

    図２８：外側と内側の遅延オブジェクトの処理の進み方


.. _figure29:

.. figure:: images/p13_deferred-111.png

    図２９：図２８におけるスレッド制御

..
    <H3>Introduction</H3>
    <P>Recall poetry client 5.1 from <A href="http://krondo.com/blog/?p=1956">Part 10</A>.The client used a Deferred to manage a <A href="http://krondo.com/blog/?p=1956#figure24">callback chain</A> that included a call to a poetry transformation engine. In <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-5/get-poetry-1.py#L1">client 5.1</A>, the engine was implemented as a synchronous function call implemented in the client itself.</P>
    <P>Now we want to make a new client that uses the networked poetry transformation service we wrote in <A href="http://krondo.com/blog/?p=2101">Part 12</A>. But here’s the wrinkle: since the transformation service is accessed over the network, we’ll need to use asynchronous I/O. And that means our API for requesting a transformation will have to be asynchronous, too. In other words, the <CODE>try_to_cummingsify</CODE> callback is going to return a <CODE>Deferred</CODE> in our new client.</P>
    <P>So what happens when a callback in a deferred’s chain returns another deferred? Let’s call the first deferred the ‘outer’ deferred and the second the ‘inner’ one. Suppose callback <STRONG>N</STRONG> in the outer deferred returns the inner deferred. That callback&nbsp; is saying “I’m asynchronous, my result isn’t here yet”. Since the outer deferred needs to call the next callback or errback in the chain with the result, the outer deferred needs to wait until the inner deferred is fired. Of course, the outer deferred can’t block either, so instead the outer deferred suspends the execution of the callback chain and returns control to the reactor (or whatever fired the outer deferred).</P>
    <P>And how does the outer deferred know when to resume? Simple — by adding a callback/errback pair to the inner deferred. Thus, when the inner deferred is fired the outer deferred will resume executing its chain. If the inner deferred succeeds (i.e., it calls the callback added by the outer deferred), then the outer deferred calls its <STRONG>N+1</STRONG> callback with the result. And if the inner deferred fails (calls the errback added by the outer deferred), the outer deferred calls the <STRONG>N+1</STRONG> errback with the failure.</P>
    <P>That’s a lot to digest, so let’s illustrate the idea in Figure 28:</P>
    <DIV id="attachment_2196" class="wp-caption aligncenter" style="width: 609px"><A href="./part13_files/deferred-111.png"><IMG class="size-full wp-image-2196" title="Figure 28: outer and inner deferred processing" src="./part13_files/deferred-111.png" alt="Figure 28: outer and inner deferred processing" width="599" height="511"></A><P class="wp-caption-text">Figure 28: outer and inner deferred processing</P></DIV>
    <P>In this figure the outer deferred has 4 layers of callback/errback pairs. When the outer deferred fires, the first callback in the chain returns a deferred (the inner deferred). At that point, the outer deferred will stop firing its chain and return control to the reactor (after adding a callback/errback pair to the inner deferred). Then, some time later, the inner deferred fires and the outer deferred resumes processing its callback chain. Note the outer deferred does <EM>not</EM> fire the inner deferred itself. That would be impossible, since the outer deferred cannot know when the inner deferred’s result is available, or what that result might be. Rather, the outer deferred simply waits (asynchronously) for the inner deferred to fire.</P>
    <P>Notice how the line connecting the callback to the inner deferred in Figure 28 is black instead of green or red. That’s because we don’t know whether the callback succeeded or failed until the inner deferred is fired. Only then can the outer deferred decide whether to call the next callback or the next errback in its own chain.</P>
    <P>Figure 29 shows the same outer/inner deferred firing sequence in Figure 28 from the point of view of the reactor:</P>
    <DIV id="attachment_2179" class="wp-caption aligncenter" style="width: 664px"><A href="./part13_files/deferred-12.png"><IMG class="size-full wp-image-2179" title="Figure 29: the thread of control in Figure 28" src="./part13_files/deferred-12.png" alt="Figure 29: the thread of control in Figure 28" width="654" height="582"></A><P class="wp-caption-text">Figure 29: the thread of control in Figure 28</P></DIV>
    <P>This is probably the most complicated feature of the <CODE>Deferred</CODE> class, so don’t worry if you need some time to absorb it. We’ll illustrate it one more way using the example code in <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-deferred/defer-10.py#L1"><TT>twisted-deferred/defer-10.py</TT></A>. That example creates two outer deferreds, one with plain callbacks, and one where a single callback returns an inner deferred. By studying the code and the output you can see how the second outer deferred stops running its chain when the inner deferred is returned, and then starts up again when the inner deferred is fired.</P>

..
    <H3>Client 6.0</H3>
    <P>Let’s use our new knowledge of nested deferreds and re-implement our poetry client to use the network transformation service from Part 12. You can find the code in <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-6/get-poetry.py#L1"><TT>twisted-client-6/get-poetry.py</TT></A>. The poetry Protocol and Factory are unchanged from the previous version. But now we have a Protocol and Factory for making transformation requests. Here’s the transform client <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-6/get-poetry.py#L85">Protocol</A>:</P>
    <PRE>class TransformClientProtocol(NetstringReceiver):

        def connectionMade(self):
            self.sendRequest(self.factory.xform_name, self.factory.poem)

        def sendRequest(self, xform_name, poem):
            self.sendString(xform_name + '.' + poem)

        def stringReceived(self, s):
            self.transport.loseConnection()
            self.poemReceived(s)

        def poemReceived(self, poem):
            self.factory.handlePoem(poem)</PRE>
    <P>Using the NetstringReceiver as a base class makes this implementation pretty simple. As soon as the connection is established we send the transform request to the server, retrieving the name of the transform and the poem from our factory. And when we get the poem back, we pass it on to the factory for processing. Here’s the code for the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-6/get-poetry.py#L101">Factory</A>:</P>
    <PRE>class TransformClientFactory(ClientFactory):

        protocol = TransformClientProtocol

        def __init__(self, xform_name, poem):
            self.xform_name = xform_name
            self.poem = poem
            self.deferred = defer.Deferred()

        def handlePoem(self, poem):
            d, self.deferred = self.deferred, None
            d.callback(poem)

        def clientConnectionLost(self, _, reason):
            if self.deferred is not None:
                d, self.deferred = self.deferred, None
                d.errback(reason)

        clientConnectionFailed = clientConnectionLost</PRE>
    <P>This factory is designed for clients and handles a single transformation request, storing both the transform name and the poem for use by the Protocol. The Factory creates a single Deferred which represents the result of the transformation request. Notice how the Factory handles two error cases: a failure to connect and a connection that is closed before the poem is received. Also note the <CODE>clientConnectionLost</CODE> method is called even if we receive the poem, but in that case <CODE>self.deferred</CODE> will be <CODE>None</CODE>, thanks to the <CODE>handlePoem</CODE> method.</P>
    <P>This Factory class creates the Deferred that it also fires. That’s a good rule to follow in Twisted programming, so let’s highlight it:</P>
    <P style="padding-left: 30px;">In general, an object that makes a Deferred should also be in charge of firing that Deferred.</P>
    <P>This “you make it, you fire it” rule helps ensure a given deferred is only fired once and makes it easier to follow the flow of control in a Twisted program.</P>
    <P>In addition to the transform Factory, there is also a <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-6/get-poetry.py#L122">Proxy</A> class which hides the details of making the TCP connection to a particular transform server:</P>
    <PRE>class TransformProxy(object):
        """
        I proxy requests to a transformation service.
        """

        def __init__(self, host, port):
            self.host = host
            self.port = port

        def xform(self, xform_name, poem):
            factory = TransformClientFactory(xform_name, poem)
            from twisted.internet import reactor
            reactor.connectTCP(self.host, self.port, factory)
            return factory.deferred</PRE>
    <P>This class presents a single <CODE>xform()</CODE> interface that other code can use to request transformations. So that other code can just request a transform and get a deferred back without mucking around with hostnames and port numbers.</P>
    <P>The rest of the program is unchanged except for the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-6/get-poetry.py#L163"><CODE>try_to_cummingsify</CODE></A> callback:</P>
    <PRE>    def try_to_cummingsify(poem):
            d = proxy.xform('cummingsify', poem)

            def fail(err):
                print &gt;&gt;sys.stderr, 'Cummingsify failed!'
                return poem

            return d.addErrback(fail)</PRE>
    <P>This callback now returns a deferred, but we didn’t have to change the rest of the <CODE>main</CODE> function at all, other than to create the Proxy instance. Since <CODE>try_to_cummingsify</CODE> was part of a deferred chain (the deferred returned by <CODE>get_poetry</CODE>), it was already being used asynchronously and nothing else need change.</P>
    <P>You’ll note we are returning the result of <CODE>d.addErrback(fail)</CODE>. That’s just a little bit of syntactic sugar. The <CODE>addCallback</CODE> and <CODE>addErrback</CODE> methods return the original deferred. We might just as well have written:</P>
    <PRE>        d.addErrback(fail)
            return d</PRE>
    <P>The first version is the same thing, just shorter.</P>

..
    <H4>Testing out the Client</H4>
    <P>The new client has a slightly different syntax than the others. If you have a transformation service running on port 10001 and two poetry servers running on ports 10002 and 10003, you would run:</P>
    <PRE>python twisted-client-6/get-poetry.py 10001 10002 10003</PRE>
    <P>To download two poems and transform them both. You can start the transform server like this:</P>
    <PRE>python twisted-server-1/tranformedpoetry.py --port 10001</PRE>
    <P>And the poetry servers like this:</P>
    <PRE>python twisted-server-1/fastpoetry.py --port 10002 poetry/fascination.txt
    python twisted-server-1/fastpoetry.py --port 10003 poetry/science.txt</PRE>
    <P>Then you can run the poetry client as above. After that, try crashing the transform server and re-running the client with the same command.</P>

..
    <H3>Wrapping Up</H3>
    <P>In this Part we learned how deferreds can transparently handle other deferreds in a callback chain, and thus we can safely add asynchronous callbacks to an ‘outer’ deferred without worrying about the details. That’s pretty handy since lots of our functions are going to end up being asynchronous.</P>
    <P>Do we know everything there is to know about deferreds yet? Not quite! There’s one more important feature to talk about, but we’ll save it for <A href="http://krondo.com/blog/?p=2205">Part 14</A>.</P>

..
    <H3>Suggested Exercises</H3>
    <OL>
    <LI>Modify the client so we can ask for a specific kind of transformation by name.</LI>
    <LI>Modify the client so the transformation server address is an optional argument. If it’s not provided, skip the transformation step.</LI>
    <LI>The <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-6/get-poetry.py#L67"><CODE>PoetryClientFactory</CODE></A> currently violates the “you make it, you fire it” rule for deferreds. Refactor <CODE>get_poetry</CODE> and <CODE>PoetryClientFactory</CODE> to remedy that.</LI>
    <LI>Although we didn’t demonstrate it, the case where an errback returns a deferred is symmetrical. Modify the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-deferred/defer-10.py#L1"><TT>twisted-deferred/defer-10.py</TT></A> example to verify it.</LI>
    <LI>Find the place in the <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-8.2.0/twisted/internet/defer.py#L137">Deferred</A> implementation that handles the case where a callback/errback returns another Deferred.</LI>
    </OL>

まとめ
------

":doc:`p14`"

おすすめの練習問題
------------------
*
*
*
