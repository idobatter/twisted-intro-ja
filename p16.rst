==================================
パート16: Twisted をデーモン化する
==================================
..
    <H2>Part 16: Twisted Daemonologie</H2>

はじめに
========
..
    <H3>Introduction</H3>

..
    <P>The servers we have written so far have just run in a terminal window, with output going to the screen via <CODE>print</CODE> statements. This works alright for development, but it’s hardly a way to deploy services in production. A well-behaved production server ought to:</P>
    <OL>
    <LI>Run as a <A href="http://en.wikipedia.org/wiki/Daemon_%28computer_software%29">daemon</A> process, unconnected with any terminal or user session. You don’t want a service to shut down just because the administrator logs out.</LI>
    <LI>Send debugging and error output to a set of rotated log files, or to the <A href="http://en.wikipedia.org/wiki/Syslog"><TT>syslog</TT></A> service.</LI>
    <LI>Drop excessive privileges, e.g., switching to a lower-privileged user before running.</LI>
    <LI>Record its <A href="http://en.wikipedia.org/wiki/Process_ID"><TT>pid</TT></A> in a file so that the administrator can easily <A href="http://en.wikipedia.org/wiki/Kill%28%29">send signals</A> to the daemon.</LI>
    </OL>
    <P>We can get all of those features by using the <TT>twistd</TT> script provided by Twisted. But first we’ll have to change our code a bit.</P>

コンセプト
==========
..
    <H3>The Concepts</H3>

..
    <P>Understanding <TT>twistd</TT> will require learning a few new concepts in Twisted, the most important being a <CODE>Service</CODE>. As usual, several of the new concepts are accompanied by new <CODE>Interface</CODE>s.</P>

IService
--------
..
    <H4>IService</H4>

..
    <P>The <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L87"><CODE>IService</CODE></A> interface defines a named service that can be started and stopped. What does the service do? Whatever you like — rather than define the specific function of the service, the interface requires only that it provide a small set of generic attributes and methods.</P>
    <P>There are two required attributes: <CODE>name</CODE> and <CODE>running</CODE>. The <CODE>name</CODE> attribute is just a string, like <CODE>'fastpoetry'</CODE>. The <CODE>running</CODE> attribute is a Boolean value and is true if the service has been successfully started.</P>
    <P>We’re only going to touch on some of the methods of <CODE>IService</CODE>. We’ll skip some that are obvious, and others that are more advanced and often go unused in simpler Twisted programs. The two principle methods of <CODE>IService</CODE> are <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L130"><CODE>startService</CODE></A> and <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L135"><CODE>stopService</CODE></A>:</P>
    <PRE>    def startService():
            """
            Start the service.
            """

        def stopService():
            """
            Stop the service.

            @rtype: L{Deferred}
            @return: a L{Deferred} which is triggered when the service has
                finished shutting down. If shutting down is immediate, a
                value can be returned (usually, C{None}).
            """</PRE>
    <P>Again, what these methods actually do will depend on the service in question. For example, the <CODE>startService</CODE> method might:</P>
    <UL>
    <LI>Load some configuration data, or</LI>
    <LI>Initialize a database, or</LI>
    <LI>Start listening on a port, or</LI>
    <LI>Do nothing at all.</LI>
    </UL>
    <P>And the <CODE>stopService</CODE> method might:</P>
    <UL>
    <LI>Persist some state, or</LI>
    <LI>Close open database connections, or</LI>
    <LI>Stop listening on a port, or</LI>
    <LI>Do nothing at all.</LI>
    </UL>
    <P>When we write our own custom services we’ll need to implement these methods appropriately. For some common behaviors, like listening on a port, Twisted provides ready-made services we can use instead.</P>
    <P>Notice that <CODE>stopService</CODE> may optionally return a deferred, which is required to fire when the service has completely shut down. This allows our services to finish cleaning up after themselves before the entire application terminates. If your service shuts down immediately you can just return <CODE>None</CODE> instead of a deferred.</P>
    <P>Services can be organized into collections that get started and stopped together. The last <CODE>IService</CODE> method we’re going to look at, <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L107"><CODE>setServiceParent</CODE></A>, adds a Service to a collection:</P>
    <PRE>    def setServiceParent(parent):
            """
            Set the parent of the service.

            @type parent: L{IServiceCollection}
            @raise RuntimeError: Raised if the service already has a parent
                or if the service has a name and the parent already has a child
                by that name.
            """</PRE>
    <P>Any service can have a parent, which means services can be organized in a hierarchy. And that brings us to the next <CODE>Interface</CODE> we’re going to look at today.</P>

IServiceCollection
------------------
..
    <H4>IServiceCollection</H4>

..
    <P>The <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L203"><CODE>IServiceCollection</CODE></A> interface defines an object which can contain <CODE>IService</CODE> objects. A service collection is a just plain container class with methods to:</P>
    <UL>
    <LI>Look up a service by name (<A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L212"><CODE>getServiceNamed</CODE></A>)</LI>
    <LI>Iterate over the services in the collection (<A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L222"><CODE>__iter__</CODE></A>)</LI>
    <LI>Add a service to the collection (<A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L227"><CODE>addService</CODE></A>)</LI>
    <LI>Remove a service from the collection (<A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L236"><CODE>removeService</CODE></A>)</LI>
    </UL>
    <P>Note that an implementation of <CODE>IServiceCollection</CODE> isn’t automatically an implementation of <CODE>IService</CODE>, but there’s no reason why one class can’t implement both interfaces (and we’ll see an example of that shortly).</P>

Application
-----------
..
    <H4>Application</H4>

..
    <P>A Twisted <CODE>Application</CODE> is not defined by a separate interface. Rather, an <CODE>Application</CODE> object is required to implement both <CODE>IService</CODE> and <CODE>IServiceCollection</CODE>, as well as a few other interfaces we aren’t going to cover.</P>
    <P>An <CODE>Application</CODE> is the top-level service that represents your entire Twisted application. All the other services in your daemon will be children (or grandchildren, etc.) of the <CODE>Application</CODE> object.</P>
    <P>It is rare to actually implement your own <CODE>Application</CODE>. Twisted provides an implementation that we’ll use today.</P>

Twisted Logging
---------------
..
    <H4>Twisted Logging</H4>

..
    <P>Twisted includes its own logging infrastructure in the module <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/python/log.py"><CODE>twisted.python.log</CODE></A>. The basic API for writing to the log is simple, so we’ll just include a short example located in <TT>basic-twisted/log.py</TT>, and you can skim the Twisted module for details if you are interested.</P>
    <P>We won’t bother showing the API for installing logging handlers, since <CODE>twistd</CODE> will do that for us.</P>

FastPoetry 2.0
--------------
..
    <H3>FastPoetry 2.0</H3>

..
    <P>Alright, let’s look at some code. We’ve updated the fast poetry server to run with <TT>twistd</TT>. The source is located in <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L1"><TT>twisted-server-3/fastpoetry.py</TT></A>. First we have the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L9">poetry protocol</A>:</P>
    <PRE>class PoetryProtocol(Protocol):

        def connectionMade(self):
            poem = self.factory.service.poem
            log.msg('sending %d bytes of poetry to %s'
                    % (len(poem), self.transport.getPeer()))
            self.transport.write(poem)
            self.transport.loseConnection()</PRE>
    <P>Notice instead of using a <CODE>print</CODE> statement, we’re using the <CODE>twisted.python.log.msg</CODE> function to record each new connection.<BR>
    Here’s the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L19">factory class</A>:</P>
    <PRE>class PoetryFactory(ServerFactory):

        protocol = PoetryProtocol

        def __init__(self, service):
            self.service = service</PRE>
    <P>As you can see, the poem is no longer stored on the factory, but on a service object referenced by the factory. Notice how the protocol gets the poem from the service via the factory. Finally, here’s the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L27">service class itself</A>:</P>
    <PRE>class PoetryService(service.Service):

        def __init__(self, poetry_file):
            self.poetry_file = poetry_file

        def startService(self):
            service.Service.startService(self)
            self.poem = open(self.poetry_file).read()
            log.msg('loaded a poem from: %s' % (self.poetry_file,))</PRE>
    <P>As with many other <CODE>Interface</CODE> classes, Twisted provides a base class we can use to make our own implementations, with helpful default behaviors. Here we use the <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L154"><CODE>twisted.application.service.Service</CODE></A> class to implement our <CODE>PoetryService</CODE>.</P>
    <P>The base class provides default implementations of all required methods, so we only need to implement the ones with custom behavior. In this case, we just override <CODE>startService</CODE> to load the poetry file. Note we still call the base class method (which sets the <CODE>running</CODE> attribute for us).</P>
    <P>Another point is worth mentioning. The <CODE>PoetryService</CODE> object doesn’t know anything about the details of the <CODE>PoetryProtocol</CODE>. The service’s only job is to load the poem and provide access to it for any object that might need it. In other words, the <CODE>PoetryService</CODE> is entirely concerned with the higher-level details of providing poetry, rather than the lower-level details of sending a poem down a TCP connection. So this same service could be used by another protocol, say UDP or XML-RPC. While the benefit is rather small for our simple service, you can imagine the advantage for a more realistic service implementation.</P>
    <P>If this were a typical Twisted program, all the code we’ve looked at so far wouldn’t actually be in this file. Rather, it would be in some other module(s) (perhaps <CODE>fastpoetry.protocol</CODE> and <CODE>fastpoetry.service</CODE>). But following our usual practice of making these examples self-contained, we’ve including everything we need in a single script.</P>

Twisted `tac` ファイル
----------------------
..
    <H4>Twisted <TT>tac</TT> files</H4>

..
    <P>The rest of the script contains what would normally be the entire content — a Twisted <TT>tac</TT> file. A <TT>tac</TT> file is a Twisted Application Configuration file that tells <CODE>twistd</CODE> how to construct an application. As a configuration file it is responsible for choosing settings (like port numbers, poetry file locations, etc.) to run the application in some particular way. In other words, a <TT>tac</TT> file represents a specific deployment of our service (serve <EM>that</EM> poem on <EM>this</EM> port) rather than a general script for starting any poetry server.</P>
    <P>If we were running multiple poetry servers on the same host, we would have a <TT>tac</TT> file for each one (so you can see why <TT>tac</TT> files normally don’t contain any general-purpose code). In our example, the <TT>tac</TT> file is configured to serve <TT>poetry/ecstasy.txt</TT> run on port <CODE>10000</CODE> of the loopback interface:</P>
    <PRE># configuration parameters
    port = 10000
    iface = 'localhost'
    poetry_file = 'poetry/ecstasy.txt'</PRE>
    <P>Note that <TT>twistd</TT> doesn’t know anything about these particular variables, we just define them here to keep all our configuration values in one place. In fact, <TT>twistd</TT> only really cares about one variable in the entire file, as we’ll see shortly. Next we <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L44">begin</A> building up our application:</P>
    <PRE># this will hold the services that combine to form the poetry server
    top_service = service.MultiService()</PRE>
    <P>Our poetry server is going to consist of two services, the <CODE>PoetryService</CODE> we defined above, and a Twisted built-in service that creates the listening socket our poem will be served from. Since these two services are clearly related to each other, we’ll group them together using a <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L253"><CODE>MultiService</CODE></A>, a Twisted class which implements both <CODE>IService</CODE> and <CODE>IServiceCollection</CODE>.</P>
    <P>As a service collection, the <CODE>MultiService</CODE> will group our two poetry services together. And as a service, the <CODE>MultiService</CODE> will start both child services when the <CODE>MultiService</CODE> itself is started, and stop both child services when it is stopped. Let’s <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L48">add</A> the first poetry service to the collection:</P>
    <PRE># the poetry service holds the poem. it will load the poem when it is
    # started
    poetry_service = PoetryService(poetry_file)
    poetry_service.setServiceParent(top_service)</PRE>
    <P>This is pretty simple stuff. We just create the <CODE>PoetryService</CODE> and then add it to the collection with <CODE>setServiceParent</CODE>, a method we inherited from the Twisted base class. Next we <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L53">add</A> the TCP listener:</P>
    <PRE># the tcp service connects the factory to a listening socket. it will
    # create the listening socket when it is started
    factory = PoetryFactory(poetry_service)
    tcp_service = internet.TCPServer(port, factory, interface=iface)
    tcp_service.setServiceParent(top_service)</PRE>
    <P>Twisted provides the <CODE>TCPServer</CODE> service for creating a TCP listening socket connected to an arbitrary factory (in this case our <CODE>PoetryFactory</CODE>). We don’t call <CODE>reactor.listenTCP</CODE> directly because the job of a <TT>tac</TT> file is to get our application ready to start, without actually starting it. The <CODE>TCPServer</CODE> will create the socket after it is started by <TT>twistd</TT>.</P>
    <P>You might have noticed we didn’t bother to give any of our services names. Naming services is not required, but only an optional feature you can use if you want to ‘look up’ services at runtime. Since we don’t need to do that in our little application, we don’t bother with it here.</P>
    <P>Ok, now we’ve got both our services combined into a collection. Now we just make our <CODE>Application</CODE> and <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-server-3/fastpoetry.py#L58">add</A> our collection to it:</P>
    <PRE># this variable has to be named 'application'
    application = service.Application("fastpoetry")

    # this hooks the collection we made to the application
    top_service.setServiceParent(application)</PRE>
    <P>The only variable in this script that <TT>twistd</TT> really cares about is the <CODE>application</CODE> variable. That is how <TT>twistd</TT> will find the application it’s supposed to start (and so the variable has to be named ‘application’). And when the application is started, all the services we added to it will be started as well.</P>
    <P>Figure 34 shows the structure of the application we just built:</P>
    <DIV id="attachment_2400" class="wp-caption aligncenter" style="width: 361px"><A href="./part16_files/application.png"><IMG class="size-full wp-image-2400 " title="Figure 34: the structure of our fastpoetry application" src="./part16_files/application.png" alt="Figure 34: the structure of our fastpoetry application" width="351" height="277"></A><P class="wp-caption-text">Figure 34: the structure of our fastpoetry application</P></DIV>

サーバを動かす
--------------
..
    <H4>Running the Server</H4>

..
    <P>Let’s take our new server for a spin. As a <TT>tac</TT> file, we need to start it with <TT>twistd</TT>. Of course, it’s also just a regular Python file, too. So let’s run it with Python first and see what happens:</P>
    <PRE>python twisted-server-3/fastpoetry.py</PRE>
    <P>If you do this, you’ll find that what happens is nothing! As we said before, the job of a <TT>tac</TT> file is to get an application ready to run, without actually running it. As a reminder of this special purpose of <TT>tac</TT> files, some people name them with a <TT>.tac</TT> extension instead of <TT>.py</TT>. But the <TT>twistd</TT> script doesn’t actually care about the extension.</P>
    <P>Let’s run our server for real, using <TT>twistd</TT>:</P>
    <PRE>twistd --nodaemon --python twisted-server-3/fastpoetry.py</PRE>
    <P>After running that command, you should see some output like this:</P>
    <PRE>2010-06-23 20:57:14-0700 [-] Log opened.
    2010-06-23 20:57:14-0700 [-] twistd 10.0.0 (/usr/bin/python 2.6.5) starting up.
    2010-06-23 20:57:14-0700 [-] reactor class: twisted.internet.selectreactor.SelectReactor.
    2010-06-23 20:57:14-0700 [-] __builtin__.PoetryFactory starting on 10000
    2010-06-23 20:57:14-0700 [-] Starting factory &lt;__builtin__.PoetryFactory instance at 0x14ae8c0&gt;
    2010-06-23 20:57:14-0700 [-] loaded a poem from: poetry/ecstasy.txt</PRE>
    <P>Here’s a few things to notice:</P>
    <OL>
    <LI>You can see the output of the Twisted logging system, including the <CODE>PoetryFactory</CODE>‘s call to <CODE>log.msg</CODE>. But we didn’t install a logger in our <TT>tac</TT> file, so <TT>twistd</TT> must have installed one for us.</LI>
    <LI>You can also see our two main services, the <CODE>PoetryService</CODE> and the <CODE>TCPServer</CODE> starting up.</LI>
    <LI>The shell prompt never came back. That means our server isn’t running as a daemon. By default, <TT>twistd</TT> does run a server as a daemon process (that’s the main reason <TT>twistd</TT> exists), but if you include the <TT>--nodaemon</TT> option then <TT>twistd</TT> will run your server as a regular shell process instead, and will direct the log output to standard output as well. This is useful for debugging your <TT>tac</TT> files.</LI>
    </OL>
    <P>Now test out the server by fetching a poem, either with one of our poetry clients or just <TT>netcat</TT>:</P>
    <PRE>netcat localhost 10000</PRE>
    <P>That should fetch the poem from the server and you should see a new log line like this:</P>
    <PRE>2010-06-27 22:17:39-0700 [__builtin__.PoetryFactory] sending 3003 bytes of poetry to IPv4Address(TCP, '127.0.0.1', 58208)</PRE>
    <P>That’s from the call to <CODE>log.msg</CODE> in <CODE>PoetryProtocol.connectionMade</CODE>. As you make more requests to the server, you will see additional log entries for each request.</P>
    <P>Now stop the server by pressing <TT>Ctrl-C</TT>. You should see some output like this:</P>
    <PRE>^C2010-06-29 21:32:59-0700 [-] Received SIGINT, shutting down.
    2010-06-29 21:32:59-0700 [-] (Port 10000 Closed)
    2010-06-29 21:32:59-0700 [-] Stopping factory &lt;__builtin__.PoetryFactory instance at 0x28d38c0&gt;
    2010-06-29 21:32:59-0700 [-] Main loop terminated.
    2010-06-29 21:32:59-0700 [-] Server Shut Down.</PRE>
    <P>As you can see, Twisted does not simply crash, but shuts itself down cleanly and tells you about it with log messages. Notice our two main services shutting themselves down as well.</P>
    <P>Ok, now start the server up once more:</P>
    <PRE>twistd --nodaemon --python twisted-server-3/fastpoetry.py</PRE>
    <P>Then open another shell and change to the <TT>twisted-intro</TT> directory. A directory listing should show a file called <TT>twistd.pid</TT>. This file is created by <TT>twistd</TT> and contains the process ID of our running server. Try executing this alternative command to shut down the server:</P>
    <PRE>kill `cat twistd.pid`</PRE>
    <P>Notice that <TT>twistd</TT> cleans up the process ID file when our server shuts down.</P>

現実のデーモン
--------------
..
    <H4>A Real Daemon</H4>

..
    <P>Now let’s start our server as an actual daemon process, which is even simpler to do as it’s <TT>twistd</TT>‘s default behavior:</P>
    <PRE>twistd --python twisted-server-3/fastpoetry.py</PRE>
    <P>This time we get our shell prompt back almost immediately. And if you list the contents of your directory you will see, in addition to the <TT>twistd.pid</TT> file for the server we just ran, a <TT>twistd.log</TT> file with the log entries that were formerly displayed at the shell prompt.</P>
    <P>When starting a daemon process, <TT>twistd</TT> installs a log handler that writes entries to a file instead of standard output. The default log file is <TT>twistd.log</TT>, located in the same directory where you ran <TT>twistd</TT>, but you can change that with the <TT>--logfile</TT> option if you wish. The handler that <TT>twistd</TT> installs also rotates the log whenever the size exceeds one megabyte.</P>
    <P>You should be able to see the server running by listing all the processes on your system. Go ahead and test out the server by fetching another poem. You should see new entries appear in the log file for each poem you request.</P>
    <P>Since the server is no longer connected to the shell (or any other process except <A href="http://en.wikipedia.org/wiki/Init"><TT>init</TT></A>), you cannot shut it down with <TT>Ctrl-C</TT>. As a true daemon process, it will continue to run even if you log out. But we can still use the <TT>twistd.pid</TT> file to stop the process:</P>
    <PRE>kill `cat twistd.pid`</PRE>
    <P>And when that happens the shutdown messages appear in the log, the <TT>twistd.pid</TT> file is removed, and our server stops running. Neato.</P>
    <P>It’s a good idea to check out some of the other <TT>twistd</TT> startup options. For example, you can tell <TT>twistd</TT> to switch to a different user or group account before starting the daemon (typically a way to drop privileges your server doesn’t need as a security precaution). We won’t bother going into those extra options, you can find them using the <TT>--help</TT> switch to <TT>twistd</TT>.</P>

Twisted のプラグイン機構
========================
..
    <H3>The Twisted Plugin System</H3>

..
    <P>Ok, now we can use <TT>twistd</TT> to start up our servers as genuine daemon processes. This is all very nice, and the fact that our “configuration” files are really just Python source files gives us a great deal of flexibility in how we set things up. But we don’t always need that much flexibility. For our poetry servers, we typically only have a few options we might care about:</P>
    <OL>
    <LI>The poem to serve.</LI>
    <LI>The port to serve it from.</LI>
    <LI>The interface to listen on.</LI>
    </OL>
    <P>Making new <TT>tac</TT> files for simple variations on those values seems rather excessive. It would be nice if we could just specify those values as options on the <TT>twistd</TT> command line. The Twisted plugin system allows us to do just that.</P>
    <P>Twisted plugins provide a way of defining named Applications, with a custom set of command-line options, that <TT>twistd</TT> can dynamically discover and run. Twisted itself comes with a set of built-in plugins. You can see them all by running <TT>twistd</TT> without any arguments. Try running it now, but outside of the <TT>twisted-intro</TT> directory. After the help section, you should see some output like this:</P>
    <PRE>    ...
        ftp                An FTP server.
        telnet             A simple, telnet-based remote debugging service.
        socks              A SOCKSv4 proxy service.
        ...</PRE>
    <P>Each line shows one of the built-in plugins that come with Twisted. And you can run any of them using <TT>twistd</TT>.<BR>
    Each plugin also comes with its own set of options, which you can discover using <TT>--help</TT>. Let’s see what the options for the <TT>ftp</TT> plugin are:</P>
    <PRE>twistd ftp --help</PRE>
    <P>Note that you need to put the <TT>--help</TT> switch after the <TT>ftp</TT> command, since you want the options for the <TT>ftp</TT> plugin rather than for <TT>twistd</TT> itself.<BR>
    We can run the <TT>ftp</TT> server with <TT>twistd</TT> just like we ran our poetry server. But since it’s a plugin, we just run it by name:</P>
    <PRE>twistd --nodaemon ftp --port 10001</PRE>
    <P>That command runs the <TT>ftp</TT> plugin in non-daemon mode on port 10001. Note the <TT>twistd</TT> option <TT>nodaemon</TT> comes before the plugin name, while the plugin-specific option <TT>port</TT> comes after the plugin name. As with our poetry server, you can stop that plugin with <TT>Ctrl-C</TT>.</P>
    <P>Ok, let’s turn our poetry server into a Twisted plugin. First we need to introduce a couple of new concepts.</P>

IPlugin
-------
..
    <H4>IPlugin</H4>

..
    <P>Any Twisted plugin must implement the <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/plugin.py#L38"><CODE>twisted.plugin.IPlugin</CODE></A> interface. If you look at the declaration of that <CODE>Interface</CODE>, you’ll find it doesn’t actually specify any methods. Implementing <CODE>IPlugin</CODE> is simply a way for a plugin to say “Hello, I’m a plugin!” so <TT>twistd</TT> can find it. Of course, to be of any use, it will have to implement some other interface and we’ll get to that shortly.</P>
    <P>But how do you know if an object actually implements an empty interface? The <CODE>zope.interface</CODE> package includes a function called <CODE>implements</CODE> that you can use to declare that a particular class implements a particular interface. We’ll see an example of that in the plugin version of our poetry server.</P>

IServiceMaker
-------------
..
    <H4>IServiceMaker</H4>

..
    <P>In addition to <CODE>IPlugin</CODE>, our plugin will implement the <A href="http://twistedmatrix.com/trac/browser/tags/releases/twisted-10.0.0/twisted/application/service.py#L25"><CODE>IServiceMaker</CODE></A> interface. An object which implements <CODE>IServiceMaker</CODE> knows how to create an <CODE>IService</CODE> that will form the heart of a running application. <CODE>IServiceMaker</CODE> specifies three attributes and a method:</P>
    <OL>
    <LI><CODE>tapname</CODE>: a string name for our plugin. The “tap” stands for Twisted Application Plugin. Note: an older version of Twisted also made use of pickled application files called “tapfiles”, but that functionality is deprecated.</LI>
    <LI><CODE>description</CODE>: a description of the plugin, which <TT>twistd</TT> will display as part of its help text.</LI>
    <LI><CODE>options</CODE>: an object which describes the command-line options this plugin accepts.</LI>
    <LI><CODE>makeService</CODE>: a method which creates a new <CODE>IService</CODE> object, given a specific set of command-line options</LI>
    </OL>
    <P>We’ll see how all this gets put together in the next version of our poetry server.</P>

Fast Poetry 3.0
===============
..
    <H3>Fast Poetry 3.0</H3>

..
    <P>Now we’re ready to take a look at the plugin version of Fast Poetry, located in <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted/plugins/fastpoetry_plugin.py#L1"><TT>twisted/plugins/fastpoetry_plugin.py</TT></A>.</P>
    <P>You might notice we’ve named these directories differently than any of the other examples. That’s because <TT>twistd</TT> requires plugin files to be located in a <TT>twisted/plugins</TT> directory, located in your Python module search path. The directory doesn’t have to be a package (i.e., you don’t need any <TT>__init__.py</TT> files) and you can have multiple <TT>twisted/plugins</TT> directories on your path and <TT>twistd</TT> will find them all. The actual filename you use for the plugin doesn’t matter either, but it’s still a good idea to name it according to the application it represents, like we have done here.</P>
    <P>The first part of our plugin contains the same poetry protocol, factory, and service implementations as our <TT>tac</TT> file. And as before, this code would normally be in a separate module but we’ve placed it in the plugin to make the example self-contained.</P>
    <P>Next comes the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted/plugins/fastpoetry_plugin.py#L45">declaration</A> of the plugin’s command-line options:</P>
    <PRE>class Options(usage.Options):

        optParameters = [
            ['port', 'p', 10000, 'The port number to listen on.'],
            ['poem', None, None, 'The file containing the poem.'],
            ['iface', None, 'localhost', 'The interface to listen on.'],
            ]</PRE>
    <P>This code specifies the plugin-specific options that a user can place after the plugin name on the <TT>twistd</TT> command line. We won’t go into details here as it should be fairly clear what is going on. Now we get to the main part of our plugin, the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted/plugins/fastpoetry_plugin.py#L56">service maker class</A>:</P>
    <PRE>class PoetryServiceMaker(object):

        implements(service.IServiceMaker, IPlugin)

        tapname = "fastpoetry"
        description = "A fast poetry service."
        options = Options

        def makeService(self, options):
            top_service = service.MultiService()

            poetry_service = PoetryService(options['poem'])
            poetry_service.setServiceParent(top_service)

            factory = PoetryFactory(poetry_service)
            tcp_service = internet.TCPServer(int(options['port']), factory,
                                             interface=options['iface'])
            tcp_service.setServiceParent(top_service)

            return top_service</PRE>
    <P>Here you can see how the <CODE>zope.interface.implements</CODE> function is used to declare that our class implements both <CODE>IServiceMaker</CODE> and <CODE>IPlugin</CODE>.</P>
    <P>You should recognize the code in <CODE>makeService</CODE> from our earlier <TT>tac</TT> file implementation. But this time we don’t need to make an <CODE>Application</CODE> object ourselves, we just create and return the top level service that our application will run and <TT>twistd</TT> will take care of the rest. Notice how we use the <CODE>options</CODE> argument to retrieve the plugin-specific command-line options given to <TT>twistd</TT>.</P>
    <P>After declaring that class, there’s only on thing left <A href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted/plugins/fastpoetry_plugin.py#L81">to do</A>:</P>
    <PRE>service_maker = PoetryServiceMaker()</PRE>
    <P>The <TT>twistd</TT> script will discover that instance of our plugin and use it to construct the top level service. Unlike the <TT>tac</TT> file, the variable name we choose is irrelevant.  What matters is that our object implements both <CODE>IPlugin</CODE> and <CODE>IServiceMaker</CODE>.</P>
    <P>Now that we’ve created our plugin, let’s run it. Make sure that you are in the <TT>twisted-intro</TT> directory, or that the <TT>twisted-intro</TT> directory is in your python module search path. Then try running <TT>twistd</TT> by itself. You should now see that “fastpoetry” is one of the plugins listed, along with the description text from our plugin file.</P>
    <P>You will also notice that a new file called <TT>dropin.cache</TT> has appeared in the <TT>twisted/plugins</TT> directory. This file is created by <TT>twistd</TT> to speed up subsequent scans for plugins.</P>
    <P>Now let’s get some help on using our plugin:</P>
    <PRE>twistd fastpoetry --help</PRE>
    <P>You should see the options that are specific to the fastpoetry plugin in the help text. Finally, let’s run our plugin:</P>
    <PRE>twistd fastpoetry --port 10000 --poem poetry/ecstasy.txt</PRE>
    <P>That will start a fastpoetry server running as a daemon. As before, you should see both <TT>twistd.pid</TT> and <TT>twistd.log</TT> files in the current directory. After testing out the server, you can shut it down:</P>
    <PRE>kill `cat twistd.pid`</PRE>
    <P>And that’s how you make a Twisted plugin.</P>

まとめ
======
..
    <H3>Summary</H3>

..
    <P>In this Part we learned about turning our Twisted servers into long-running daemons. We touched on the Twisted logging system and on how to use <TT>twistd</TT> to start a Twisted application as a daemon process, either from a <TT>tac</TT> configuration file or a Twisted plugin. In <A href="http://krondo.com/blog/?p=2441">Part 17</A> we’ll return to the more fundamental topic of asynchronous programming and look at another way of structuring our callbacks in Twisted.</P>

おすすめの練習問題
------------------
..
    <H3>Suggested Exercises</H3>

..
    <OL>
    <LI>Modify the <TT>tac</TT> file to serve a second poem on another port. Keep the services for each poem separate by using another <CODE>MultiService</CODE> object.</LI>
    <LI>Create a new <TT>tac</TT> file that starts a poetry proxy server.</LI>
    <LI>Modify the plugin file to accept an optional second poetry file and second port to serve it on.</LI>
    <LI>Create a new plugin for the poetry proxy server.</LI>
    </OL>
