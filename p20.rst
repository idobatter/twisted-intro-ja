===========================================
パート20: 車輪の中の車輪: Twisted と Erlang
===========================================
..
    <h2 class="lwe-editable-pre">Part 20: Wheels within Wheels: Twisted and Erlang

はじめに
========
..
    <h3 class="lwe-editable-pre">Introduction

..
    One fact we've uncovered in this series is that mixing synchronous "plain Python" code with asynchronous Twisted code is not a straightforward task, since blocking for an indeterminate amount of time in a Twisted program will eliminate many of the benefits you are trying to achieve using the asynchronous model.
    If this is your first introduction to asynchronous programming it may seem as if the knowledge you have gained is of somewhat limited applicability. You can use these new techniques inside of Twisted, but not in the much larger world of general Python code. And when working with Twisted, you are generally limited to libraries written specifically for use as part of a Twisted program, at least if you want to call them directly from the thread running the reactor.
    But asynchronous programming techniques have been around for quite some time and are hardly confined to Twisted. There are in fact a startling number of asynchronous programming frameworks in Python alone. A bit of <a href="http://www.google.com/search?q=python+async+frameworks" class="lwe-editable-pre">searching around</a> will probably yield a couple dozen of them. They differ from Twisted in their details, but the basic ideas (asynchronous I/O, processing data in small chunks across multiple data streams) are the same. So if you need, or choose, to use an alternative framework you will already have a head start having learned Twisted.
    And moving outside of Python, there are plenty of other languages and systems that are either based around, or make use of, the asynchronous programming model. Your knowledge of Twisted will continue serve you as you explore the wider areas of this subject.
    In this Part we're going to take a very brief look at <a href="http://erlang.org/" class="lwe-editable-pre">Erlang</a>, a programming language and runtime system that makes extensive use of asynchronous programming concepts, but does so in a unique way. Please note this is not meant as a general introduction to Erlang. Rather, it is a short exploration of some of the ideas embedded in Erlang and how they connect with the ideas in Twisted. The basic theme is the knowledge you have gained learning Twisted can be applied when learning other technologies.

思い出されるコールバック
========================
..
    <h3 class="lwe-editable-pre">Callbacks Reimagined

..
    Consider <a href="http://krondo.com/blog/?p=1333#figure6" class="lwe-editable-pre">Figure 6</a>, a graphical representation of a callback. The principle callback in <a href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py#L1" class="lwe-editable-pre">Poetry Client 3.0</a>, introduced in <a href="http://krondo.com/blog/?p=1595" class="lwe-editable-pre">Part 6</a>, and all subsequent poetry clients is the <a href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-3/get-poetry.py#L56" class="lwe-editable-pre"><code class="lwe-editable-pre">dataReceived</code></a> method. That callback is invoked each time we get a bit more poetry from one of the poetry servers we have connected to.
    Let's say our client is downloading three poems from three different servers. Looking at things from the point of view of the reactor (and that's the viewpoint we've emphasized the most in this series), we've got a single big loop which makes one or more callbacks each time it goes around. See Figure 40:
    <div id="attachment_2706" class="wp-caption alignnone" style="width: 213px"><a href="./part20_files/reactor-2.png"><img class="size-full wp-image-2706" title="Figure 40: callbacks from the reactor viewpoint" src="./part20_files/reactor-2.png" alt="Figure 40: callbacks from the reactor viewpoint" width="203" height="286"></a><p class="wp-caption-text lwe-editable-pre">Figure 40: callbacks from the reactor viewpoint</div>
    This figure shows the reactor happily spinning around, calling <code class="lwe-editable-pre">dataReceived</code> as the poetry comes in. Each invocation of <code class="lwe-editable-pre">dataReceived</code> is applied to one particular instance of our <code class="lwe-editable-pre">PoetryProtocol</code> class. And we know there are three instances because we are downloading three poems (and so there must be three connections).
    Let's think about this picture from the point of view of <em class="lwe-editable-pre">one</em> of those Protocol instances. Remember each Protocol is only concerned with a single connection (and thus a single poem). That instance "sees" a stream of method calls, each one bearing the next piece of the poem, like this:
    <pre class="lwe-editable-pre">dataReceived(self, "When I have fears")
    dataReceived(self, " that I may cease to be")
    dataReceived(self, "Before my pen has glea")
    dataReceived(self, "n'd my teeming brain")
    ...
    While this isn't strictly speaking an actual Python loop, we can conceptualize it as one:
    <pre class="lwe-editable-pre">for data in poetry_stream(): # pseudo-code
        dataReceived(data)
    We can envision this "callback loop" in Figure 41:
    <div id="attachment_2718" class="wp-caption alignnone" style="width: 202px"><a href="./part20_files/callback-loop.png"><img class="size-full wp-image-2718" title="Figure 41: A virtual callback loop" src="./part20_files/callback-loop.png" alt="Figure 41: A virtual callback loop" width="192" height="168"></a><p class="wp-caption-text lwe-editable-pre">Figure 41: A virtual callback loop</div>
    Again, this is not a <code class="lwe-editable-pre">for</code> loop or a <code class="lwe-editable-pre">while</code> loop. The only significant Python loop in our poetry clients is the reactor. But we can think of each Protocol as a virtual loop that ticks around once each time some poetry for that particular poem comes in. With that in mind we can re-imagine the entire client in Figure 42:
    <div id="attachment_2723" class="wp-caption alignnone" style="width: 217px"><a href="./part20_files/reactor-3.png"><img class="size-full wp-image-2723" title="Figure 42: the reactor spinning some virtual loops" src="./part20_files/reactor-3.png" alt="Figure 42: the reactor spinning some virtual loops" width="207" height="260"></a><p class="wp-caption-text lwe-editable-pre">Figure 42: the reactor spinning some virtual loops</div>
    In this figure we have one big loop, the reactor, and three virtual loops, the individual poetry protocol instances. The big loop spins around and, in so doing, causes the virtual loops to tick over as well, like a set of interlocking gears.

Erlang 入門
===========
..
    <h3 class="lwe-editable-pre">Enter Erlang

..
    <a href="http://erlang.org/" class="lwe-editable-pre">Erlang</a>, like Python, is a general purpose dynamically typed programming language originally created in the 80′s.  Unlike Python, Erlang is functional rather than object-oriented, and has a syntax reminiscent of <a href="http://en.wikipedia.org/wiki/Prolog" class="lwe-editable-pre">Prolog</a>, the language in which Erlang was originally implemented. Erlang was designed for building highly reliable distributed telephony systems, and thus Erlang contains extensive networking support.
    One of Erlang's most distinctive features is a concurrency model involving lightweight processes. An Erlang process is neither an operating system process nor an operating system thread. Rather, it is an independently running function inside the Erlang runtime with its own stack. Erlang processes are not lightweight threads because Erlang processes cannot share state (and most data types are immutable anyway, Erlang being a functional programming language). An Erlang process can interact with other Erlang processes only by sending messages, and messages are always, at least conceptually, copied and never shared.
    So an Erlang program might look like Figure 43:
    <div id="attachment_2735" class="wp-caption alignnone" style="width: 213px"><a href="./part20_files/erlang-11.png"><img class="size-full wp-image-2735" title="Figure 43: An Erlang program with three processes" src="./part20_files/erlang-11.png" alt="Figure 43: An Erlang program with three processes" width="203" height="290"></a><p class="wp-caption-text lwe-editable-pre">Figure 43: An Erlang program with three processes</div>
    In this figure the individual processes have become "real", since processes are first-class constructs in Erlang, just like objects are in Python. And the runtime has become "virtual", not because it isn't there, but because it's not necessarily a simple loop. The Erlang runtime may be multi-threaded and, as it has to implement a full-blown programming language, it's in charge of a lot more than handling asynchronous I/O. Furthermore, a language runtime is not so much an extra construct, like the reactor in Twisted, as the medium in which the Erlang processes and code execute.
    So an even better picture of an Erlang program might be Figure 44:
    <div id="attachment_2738" class="wp-caption alignnone" style="width: 343px"><a href="./part20_files/erlang-2.png"><img class="size-full wp-image-2738" title="Figure 44: An Erlang program with several processes" src="./part20_files/erlang-2.png" alt="Figure 44: An Erlang program with several processes" width="333" height="239"></a><p class="wp-caption-text lwe-editable-pre">Figure 44: An Erlang program with several processes</div>
    Of course, the Erlang runtime does have to use asynchronous I/O and one or more select loops, because Erlang allows you to create <em class="lwe-editable-pre">lots</em> of processes. Large Erlang programs can start tens or hundreds of thousands of Erlang processes, so allocating an actual OS thread to each one is simply out of the question. If Erlang is going to allow multiple processes to perform I/O, and still allow other processes to run even if that I/O blocks, then asynchronous I/O will have to be involved.
    Note that our picture of an Erlang program has each process running "under its own power", rather than being spun around by callbacks. And that is very much the case. With the job of the reactor subsumed into the fabric of the Erlang runtime, the callback no longer has a central role to play. What would, in Twisted, be solved by using a callback would, in Erlang, be solved by sending an asynchronous message from one Erlang process to another.

Erlang による詩のクライアント
=============================
..
    <h3 class="lwe-editable-pre">An Erlang Poetry Client

..
    Let's look at an Erlang poetry client. We're going to jump straight to a working version instead of building up slowly like we did with Twisted. Again, this isn't meant as a complete Erlang introduction. But if it piques your interest, we suggest some more in-depth reading at the end of this Part.
    The Erlang client is listed in <a href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L1" class="lwe-editable-pre"><tt class="lwe-editable-pre">erlang-client-1/get-poetry</tt></a>. In order to run it you will, of course, need <a href="http://erlang.org/" class="lwe-editable-pre">Erlang</a> installed. Here's the code for the <a href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L96" class="lwe-editable-pre"><code class="lwe-editable-pre">main</code></a> function, which serves a similar purpose as the main functions in our Python clients:
    <pre class="lwe-editable-pre">main([]) -&gt;
        usage();

    main(Args) -&gt;
        Addresses = parse_args(Args),
        Main = self(),
        [erlang:spawn_monitor(fun () -&gt; get_poetry(TaskNum, Addr, Main) end)
         || {TaskNum, Addr} &lt;- enumerate(Addresses)],
        collect_poems(length(Addresses), []).
    If you've never seen Prolog or a similar language before then Erlang syntax is going to seem a little odd. But some people say that about Python, too. The main function is defined by two separate clauses, separated by a semicolon. Erlang chooses which clause to run by matching the arguments, so the first clause only runs if we execute the client without providing any command line arguments, and it just prints out a help message. The second clause is where all the action is.
    Individual statements in an Erlang function are separated by commas, and all functions end with a period. Let's take each line in the second clause one at a time. The first line is just parsing the command line arguments and binding them to a variable (all variables in Erlang must be capitalized). The second line is using the Erlang <code class="lwe-editable-pre">self</code> function to get the process ID of the currently running Erlang process (not OS process). Since this is the main function you can kind of think of it as the equivalent of the <code class="lwe-editable-pre">__main__</code> module in Python. The third line is the most interesting:
    <pre class="lwe-editable-pre">[erlang:spawn_monitor(fun () -&gt; get_poetry(TaskNum, Addr, Main) end)
         || {TaskNum, Addr} &lt;- enumerate(Addresses)],
    This statement is an Erlang list comprehension, with a syntax similar to that in Python. It is spawning new Erlang processes, one for each poetry server we need to contact. And each process will run the same function (<code class="lwe-editable-pre">get_poetry</code>) but with different arguments specific to that server. We also pass the PID of the main process so the new processes can send the poetry back (you generally need the PID of a process to send a message to it).
    The last statement in <code class="lwe-editable-pre">main</code> calls the <code class="lwe-editable-pre">collect_poems</code> function which waits for the poetry to come back and for the <code class="lwe-editable-pre">get_poetry</code> processes to finish. We'll look at the other functions in a bit, but first you might compare this Erlang<br>
    <a href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L96" class="lwe-editable-pre"><code class="lwe-editable-pre">main</code></a> function to the <a href="http://github.com/jdavisp3/twisted-intro/blob/master/twisted-client-4/get-poetry.py#L96" class="lwe-editable-pre">equivalent main</a> in one of our Twisted clients.
    Now let's look at the Erlang <code class="lwe-editable-pre">get_poetry</code> function. There are actually two functions in our script called <code class="lwe-editable-pre">get_poetry</code>. In Erlang, a function is identified by both name and arity, so our script contains two separate functions, <code class="lwe-editable-pre">get_poetry/3</code> and <code class="lwe-editable-pre">get_poetry/4</code> which accept three and four arguments respectively. Here's <a href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L79" class="lwe-editable-pre"><code class="lwe-editable-pre">get_poetry/3</code></a>, which is spawned by <code class="lwe-editable-pre">main</code>:
    <pre class="lwe-editable-pre">get_poetry(Tasknum, Addr, Main) -&gt;
        {Host, Port} = Addr,
        {ok, Socket} = gen_tcp:connect(Host, Port,
                                       [binary, {active, false}, {packet, 0}]),
        get_poetry(Tasknum, Socket, Main, []).
    This function first makes a TCP connection, just like the Twisted client <code class="lwe-editable-pre">get_poetry</code>. But then, instead of returning, it proceeds to use that TCP connection by calling <a href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L85" class="lwe-editable-pre"><code class="lwe-editable-pre">get_poetry/4</code></a>, listed below:
    <pre class="lwe-editable-pre">get_poetry(Tasknum, Socket, Main, Packets) -&gt;
        case gen_tcp:recv(Socket, 0) of
            {ok, Packet} -&gt;
                io:format("Task ~w: got ~w bytes of poetry from ~s\n",
                          [Tasknum, size(Packet), peername(Socket)]),
                get_poetry(Tasknum, Socket, Main, [Packet|Packets]);
            {error, _} -&gt;
                Main ! {poem, list_to_binary(lists:reverse(Packets))}
        end.
    This Erlang function is doing the work of the <code class="lwe-editable-pre">PoetryProtocol</code> from our Twisted client, except it does so using blocking function calls. The <code class="lwe-editable-pre">gen_tcp:recv</code> function waits until some data arrives on the socket (or the socket is closed), however long that might be. But a "blocking" function in Erlang only blocks the process running the function, not the entire Erlang runtime. That TCP socket isn't really a blocking socket (you can't make a true blocking socket in pure Erlang code). For each of those Erlang sockets there is, somewhere inside the Erlang runtime, a "real" TCP socket set to non-blocking mode and used as part of a select loop.
    But the Erlang process doesn't have to know about any of that. It just just waits for some data to arrive and, if it blocks, some other Erlang process can run instead. And even if a process never blocks, the Erlang runtime is free to switch execution from that process to another at any time. In other words, Erlang has a non-cooperative concurrency model.
    Notice that <code class="lwe-editable-pre">get_poetry/4</code>, after receiving a bit of poem, proceeds by recursively calling itself. To an imperative language programmer this might seem like a recipe for running out of memory, but the Erlang compiler can optimize "tail" calls (function calls that are the last statement in a function) into loops. And this highlights another curious parallel between the Erlang and Twisted clients. In the Twisted client, the "virtual" loops are created by the reactor calling the same function (<code class="lwe-editable-pre">dataReceived</code>) over and over again. And in the Erlang client, the "real" processes running (<code class="lwe-editable-pre">get_poetry/4</code>) form loops by calling <em class="lwe-editable-pre">themselves</em> over and over again via <a href="http://stackoverflow.com/questions/310974/what-is-tail-call-optimization" class="lwe-editable-pre">tail-call optimization</a>. How about that.
    If the connection is closed, the last thing <code class="lwe-editable-pre">get_poetry</code> does is send the poem to the main process. That also ends the process that <code class="lwe-editable-pre">get_poetry</code> is running, as there is nothing left for it to do.
    The remaining key function in our Erlang client is <a href="http://github.com/jdavisp3/twisted-intro/blob/master/erlang-client-1/get-poetry#L58" class="lwe-editable-pre"><code class="lwe-editable-pre">collect_poems</code></a>:
    <pre class="lwe-editable-pre">collect_poems(0, Poems) -&gt;
        [io:format("~s\n", [P]) || P &lt;- Poems];
    collect_poems(N, Poems) -&gt;
        receive
            {'DOWN', _, _, _, _} -&gt;
                collect_poems(N-1, Poems);
            {poem, Poem} -&gt;
                collect_poems(N, [Poem|Poems])
        end.
    This function is run by the main process and, like <code class="lwe-editable-pre">get_poetry</code>, it recursively loops on itself. It also blocks. The <code class="lwe-editable-pre">receive</code> statement tells the process to wait for a message to arrive that matches one of the given patterns, and<br>
    then extract the message from its "mailbox".
    The <code class="lwe-editable-pre">collect_poems</code> function waits for two kinds of messages: poems and "DOWN" notifications. The latter is a message sent to the main process when one of the <code class="lwe-editable-pre">get_poetry</code> processes dies for any reason (this is the <code class="lwe-editable-pre">monitor</code> part of <code class="lwe-editable-pre">spawn_monitor</code>). By counting <code class="lwe-editable-pre">DOWN</code> messages, we know when all the poetry has finished. The former is a message from one of the <code class="lwe-editable-pre">get_poetry</code> processes containing one complete poem.
    Ok, let's take the Erlang client out for a spin. First start up three slow poetry servers:
    <pre class="lwe-editable-pre">python blocking-server/slowpoetry.py --port 10001 poetry/fascination.txt
    python blocking-server/slowpoetry.py --port 10002 poetry/science.txt
    python blocking-server/slowpoetry.py --port 10003 poetry/ecstasy.txt --num-bytes 30
    Now we can run the Erlang client, which has a similar command-line syntax as the Python clients. If you are on a Linux or other UNIX-like system, then you should be able to run the client directly (assuming you have Erlang installed and available in your <tt class="lwe-editable-pre">PATH</tt>). On Windows you will probably need to run the <tt class="lwe-editable-pre">escript</tt> program, with the path to th Erlang client as the first argument (with the remaining arguments for the Erlang client itself).
    <pre class="lwe-editable-pre">./erlang-client-1/get-poetry 10001 10002 10003
    After that you should see output like this:
    <pre class="lwe-editable-pre">Task 3: got 30 bytes of poetry from 127:0:0:1:10003
    Task 2: got 10 bytes of poetry from 127:0:0:1:10002
    Task 1: got 10 bytes of poetry from 127:0:0:1:10001
    ...
    This is just like one of our earlier Python clients where we print a message for each little bit of poetry we get. When all the poems have finished the client should print out the complete text of each one. Notice the client is switching back and forth between all the servers depending on which one has some poetry to send.
    Figure 45 shows the process structure of our Erlang client:
    <div id="attachment_2768" class="wp-caption alignnone" style="width: 284px"><a href="./part20_files/erlang-3.png"><img class="size-full wp-image-2768" title="Figure 45: Erlang poetry client" src="./part20_files/erlang-3.png" alt="Figure 45: Erlang poetry client" width="274" height="236"></a><p class="wp-caption-text lwe-editable-pre">Figure 45: Erlang poetry client</div>
    This figure shows three <code class="lwe-editable-pre">get_poetry</code> processes (one per server) and one main process. You can also see the messages that flow from the poetry processes to main process.
    So what happens if one of those servers is down? Let's try it:
    <pre class="lwe-editable-pre">./erlang-client-1/get-poetry 10001 10005
    The above command contains one active port (assuming you left all the earlier poetry servers running) and one inactive port (assuming you aren't running any server on port 10005). And we get some output like this:
    <pre class="lwe-editable-pre">Task 1: got 10 bytes of poetry from 127:0:0:1:10001

    =ERROR REPORT==== 25-Sep-2010::21:02:10 ===
    Error in process &lt;0.33.0&gt; with exit value: {{badmatch,{error,econnrefused}},[{erl_eval,expr,3}]}

    Task 1: got 10 bytes of poetry from 127:0:0:1:10001
    Task 1: got 10 bytes of poetry from 127:0:0:1:10001
    ...
    And eventually the client finishes downloading the poem from the active server, prints out the poem, and exits. So how did the <code class="lwe-editable-pre">main</code> function know that both processes were done? That error message is the clue. The error happens when <code class="lwe-editable-pre">get_poetry</code> tries to connect to the server and gets a connection refused error instead of the expected value (<code class="lwe-editable-pre">{ok, Socket}</code>). The resulting exception is called <tt class="lwe-editable-pre">badmatch</tt> because Erlang "assignment" statements are really pattern-matching operations.
    An unhandled exception in an Erlang process causes the process to "crash", which means the process stops running and all of its resources are garbage collected. But the <code class="lwe-editable-pre">main</code> process, which is monitoring all of the <code class="lwe-editable-pre">get_poetry</code> processes, will receive a <code class="lwe-editable-pre">DOWN</code> message when any of those processes stops running for any reason. And thus our client exits when it should instead of running forever.

議論
====
..
    <h3 class="lwe-editable-pre">Discussion

..
    Let's take stock of some of the parallels between the Twisted and Erlang clients:
    <ol>
    * Both clients connect (or try to connect) to all the poetry servers at once.
    * Both clients receive data from the servers as soon as it comes in, regardless of which server delivers the data.
    * Both clients process the poetry in little bits, and thus have to save the portion of the poems received thus far.
    * Both clients create an "object" (either a Python object or an Erlang process) to handle all the work for one particular server.
    * Both clients have to carefully determine when all the poetry has finished, regardless of whether a particular download succeeded or failed.
    </ol>
    And finally, the <code class="lwe-editable-pre">main</code> functions in both clients asynchronously receive poems and "task done" notifications. In the Twisted client this information is delivered via a <code class="lwe-editable-pre">Deferred</code> while the Erlang client receives inter-process messages.
    Notice how similar both clients are, in both their overall strategy and the structure of their code. The mechanics are a bit different, with objects, deferreds, and callbacks on the one hand and processes and messages on the other. But the high-level mental models of both clients are quite similar, and it's pretty easy to move from one to the other once you are familiar with both.
    Even the reactor pattern reappears in the Erlang client in miniaturized form. Each Erlang process in our poetry client eventually turns into a recursive loop that:
    <ol>
    * Waits for something to happen (a bit of poetry comes in, a poem is delivered, another process finishes), and
    * Takes some appropriate action.
    </ol>
    You can think of an Erlang program as a big collection of little reactors, each spinning around and occasionally sending a message to another little reactor (which will process that message as just another event).
    And if you delve deeper into Erlang you will find callbacks making an appearance. The Erlang <a href="http://www.erlang.org/doc/man/gen_server.html" class="lwe-editable-pre"><code class="lwe-editable-pre">gen_server</code></a> process is a generic reactor loop that you "instantiate" by providing a fixed set of callback functions, a pattern repeated elsewhere in the Erlang system.
    So if, having learned Twisted, you ever decide to give Erlang a try I think you will find yourself in familiar mental territory.

さらに読むべきもの
==================
..
    <h3 class="lwe-editable-pre">Further Reading

..
    In this Part we've focused on the similarities between Twisted and Erlang, but there are of course many differences. One particularly unique feature of Erlang is its approach to error handling. A large Erlang program is structured as a tree of processes, with "supervisors" in the higher branches and "workers" in the leaves. And if a worker process crashes, a supervisor process will notice and take some action (typically restarting the failed worker).
    If you are interested in learning more Erlang then you are in luck. Several Erlang books have either been published recently, or will be published shortly:
    <ul>
    * <a href="http://www.amazon.com/exec/obidos/ASIN/193435600X/krondonet-20" class="lwe-editable-pre">Programming Erlang</a> — written by one of Erlang's inventors. A great introduction to the language.
    * <a href="http://www.amazon.com/exec/obidos/ASIN/0596518188/krondonet-20" class="lwe-editable-pre">Erlang Programming</a> — this complements the Armstrong book and goes into more detail in several key areas.
    * <a href="http://www.amazon.com/exec/obidos/ASIN/1933988789/krondonet-20" class="lwe-editable-pre">Erlang and OTP in Action</a> — this hasn't been published yet, but I am eagerly awaiting my copy. Neither of the first two books really addresses OTP, the Erlang framework for building large apps. Full disclosure: two of the authors are friends of mine.
    </ul>
    Well that's it for Erlang. In the <a href="http://krondo.com/blog/?p=2814" class="lwe-editable-pre">next Part</a> we will look at Haskell, another functional language with a very different feel from either Python or Erlang. Nevertheless, we shall endeavor to find some common ground.

おすすめの練習問題
------------------
..
    <h3 class="lwe-editable-pre">Suggested Exercises for the Highly Motivated

..
    <ol>
    * Go through the Erlang and Python clients and identify where they are similar and where they differ. How do they each handle errors (like a failure to connect to a poetry server)?
    * Simplify the Erlang client so it no longer prints out each bit of poetry that comes in (so you don't need to keep track of task numbers either).
    * Modify the Erlang client to measure the time it takes to download each poem.
    * Modify the Erlang client to print out the poems in the same order as they were given on the command line.
    * Modify the Erlang client to print out a more readable error message when we can't connect to a poetry server.
    * Write Erlang versions of the poetry servers we made with Twisted.
    </ol>
