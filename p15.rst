========================
パート15: テストされた詩
========================
..
    <H2>Part 15: Tested Poetry</H2>

はじめに
========
..
    <H3>Introduction</H3>

..
    <P>We’ve written a lot of code in our exploration of Twisted, but so far we’ve neglected to write something important — tests. And you may be wondering how you can test asynchronous code using a synchronous framework like the <A href="http://docs.python.org/library/unittest.html#module-unittest"><CODE>unittest</CODE></A> package that comes with Python. The short answer is you can’t. As we’ve discovered, synchronous and asynchronous code do not mix, at least not readily.</P>
    <P>Fortunately, Twisted includes its own testing framework called <A href="http://twistedmatrix.com/documents/current/core/howto/testing.html"><CODE>trial</CODE></A> that does support testing asynchronous code (and you can use it to test synchronous code, too).</P>
    <P>We’ll assume you are already familiar with the basic mechanics of <A href="http://docs.python.org/library/unittest.html#module-unittest"><CODE>unittest</CODE></A> and similar testing frameworks, in which you create tests by defining a class with a specific parent class (usually called something like <CODE>TestCase</CODE>), and each method of that class starting with the word “<CODE>test</CODE>” is considered a single test. The framework takes care of discovering all the tests, running them one after the other with optional&nbsp;<CODE>setUp</CODE> and <CODE>tearDown</CODE> steps, and then reporting the results.</P>

例
==
..
    <H3>The Example</H3>

..
    <P>You will find some example tests located in <A href="http://github.com/jdavisp3/twisted-intro/blob/master/tests/test_poetry.py#L1"><TT>tests/test_poetry.py</TT></A>. To ensure all our examples are self-contained (so you don’t need to worry about <TT>PYTHONPATH</TT> settings), we have copied all the necessary code into the test module. Normally, of course, you would just import the modules you wanted to test.</P>
    <P>The example is testing both the poetry client and server, by using the client to fetch a poem from a test server. To provide a poetry server for testing, we implement the <A href="http://github.com/jdavisp3/twisted-intro/blob/master/tests/test_poetry.py#L70"><CODE>setUp</CODE></A> method in our test case:</P>
    <PRE>class PoetryTestCase(TestCase):

        def setUp(self):
            factory = PoetryServerFactory(TEST_POEM)
            from twisted.internet import reactor
            self.port = reactor.listenTCP(0, factory, interface="127.0.0.1")
            self.portnum = self.port.getHost().port</PRE>
    <P>The <CODE>setUp</CODE> method makes a poetry server with a test poem, and listens on a random, open port. We save the port number so the actual tests can use it, if they need to. And, of course, we clean up the test server in <A href="http://github.com/jdavisp3/twisted-intro/blob/master/tests/test_poetry.py#L76"><CODE>tearDown</CODE></A> when the test is done:</P>
    <PRE>    def tearDown(self):
            port, self.port = self.port, None
            return port.stopListening()</PRE>
    <P>That brings us to our first test, <A href="http://github.com/jdavisp3/twisted-intro/blob/master/tests/test_poetry.py#L80"><CODE>test_client</CODE></A>, where we use <CODE>get_poetry</CODE> to retrieve the poem from the test server and verify it’s the poem we expected:</P>
    <PRE>    def test_client(self):
            """The correct poem is returned by get_poetry."""
            d = get_poetry('127.0.0.1', self.portnum)

            def got_poem(poem):
                self.assertEquals(poem, TEST_POEM)

            d.addCallback(got_poem)

            return d</PRE>
    <P>Notice that our test function is returning a deferred. Under <TT>trial</TT>, each test method runs as a callback. That means the reactor is running and we can perform asynchronous operations as part of the test. We just need to let the framework know that our test is asynchronous and we do that in the usual Twisted way — return a deferred.</P>
    <P>The <TT>trial</TT> framework will wait until the deferred fires before calling the <CODE>tearDown</CODE> method, and will fail the test if the deferred fails (i.e., if the last callback/errback pair fails). It will also fail the test if our deferred takes too long to fire, two minutes by default. And that means if the test finished, we know our deferred fired, and therefore our callback fired and ran the <CODE>assertEquals</CODE> test method.</P>
    <P>Our second test, <A href="http://github.com/jdavisp3/twisted-intro/blob/master/tests/test_poetry.py#L91"><CODE>test_failure</CODE></A>, verifies that <CODE>get_poetry</CODE> fails in the appropriate way if we can’t connect to the server:</P>
    <PRE>    def test_failure(self):
            """The correct failure is returned by get_poetry when
            connecting to a port with no server."""
            d = get_poetry('127.0.0.1', -1)
            return self.assertFailure(d, ConnectionRefusedError)</PRE>
    <P>Here we attempt to connect to an invalid port and then use the <TT>trial</TT>-provided <CODE>assertFailure</CODE> method. This method is like the familiar <CODE>assertRaises</CODE> method but for asynchronous code. It returns a deferred that succeeds if the given deferred fails with the given exception, and fails otherwise.</P>
    <P>You can run the tests yourself using the <TT>trial</TT> script like this:</P>
    <PRE>trial tests/test_poetry.py</PRE>
    <P>And you should see some output showing each test case and an <TT>OK</TT> telling you each test passed.</P>

議論
====
..
    <H3>Discussion</H3>

..
    <P>Because <CODE>trial</CODE> is so similar to <CODE>unittest</CODE> when it comes to the basic API, it’s pretty easy to get started writing tests. Just return a deferred if your test uses asynchronous code, and <CODE>trial</CODE> will take care of the rest. You can also return a deferred from the <CODE>setUp</CODE> and <CODE>tearDown</CODE> methods, if those need to be asynchronous as well.</P>
    <P>Any log messages from your tests will be collected in a file inside a directory called <TT>_trial_temp</TT> that <TT>trial</TT> will create automatically if it doesn’t exist. In addition to the errors printed to the screen, the log is a useful starting point when debugging failing tests.</P>
    <P>Figure 33 shows a hypothetical test run in progress:<BR>
    </P><DIV id="attachment_2323" class="wp-caption aligncenter" style="width: 594px"><A href="./part15_files/test-1.png"><IMG src="./part15_files/test-1.png" alt="Figure 33: a trial test in progress" title="Figure 33: a trial test in progress" width="584" height="464" class="size-full wp-image-2323"></A><P class="wp-caption-text">Figure 33: a trial test in progress</P></DIV><P></P>
    <P>If you’ve used similar frameworks before, this should be a familiar model, except that all the test-related methods may return deferreds.</P>
    <P>The <TT>trial</TT> framework is also a good illustration of how “going asynchronous” involves changes that cascade throughout the program. In order for a test (or any function or method) to be asynchronous, it must:</P>
    <OL>
    <LI>Not block and, usually,</LI>
    <LI>return a deferred.</LI>
    </OL>
    <P>But that means that whatever calls that function must be willing to accept a deferred, and also not block (and thus likely return a deferred as well). And so it goes up and up. Thus, the need for a framework like <TT>trial</TT> which can handle asynchronous tests that return deferreds.</P>

まとめ
======
..
    <H3>Summary</H3>

..
    <P>That’s it for our look at unit testing. If would like to see more examples of how to write unit tests for Twisted code, you need look no further than Twisted itself. The Twisted framework comes with a very large suite of unit tests, with new ones added in each release. Since these tests are scrutinized by Twisted experts during code reviews before being accepted into the codebase, they make excellent examples of how to test Twisted code the right way.</P>
    <P>In <A href="http://krondo.com/blog/?p=2345">Part 16</A> we will use a Twisted utility to turn our poetry server into a genuine daemon.</P>

おすすめの練習問題
==================
..
    <H3>Suggested Exercises</H3>

..
    <OL>
    <LI>Change one of the tests to make it fail and run <CODE>trial</CODE> again to see the output.</LI>
    <LI>Read the online <A href="http://twistedmatrix.com/documents/current/core/howto/testing.html">trial documentation</A>.</LI>
    <LI>Write tests for some of the other poetry services we have created in this series.</LI>
    <LI>Explore <A href="http://twistedmatrix.com/trac/browser/trunk/twisted/test">some of the tests</A> in Twisted.</LI>
    </OL>
